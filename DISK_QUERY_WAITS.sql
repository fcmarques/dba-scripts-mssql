	-- Processes that are disk intensive typically do not have the appropriate indexes or have poor execution plans. Here is a DMV query that lists the top 25 tables experiencing I/O waits.

	SELECT TOP 25 DB_NAME(D.DATABASE_ID) AS
	DATABASE_NAME, 
	QUOTENAME(OBJECT_SCHEMA_NAME(D.OBJECT_ID, 
	D.DATABASE_ID)) + N'.' +
	QUOTENAME(OBJECT_NAME(D.OBJECT_ID,
	D.DATABASE_ID)) AS OBJECT_NAME, D.DATABASE_ID, 
	D.OBJECT_ID, D.PAGE_IO_LATCH_WAIT_COUNT,
	D.PAGE_IO_LATCH_WAIT_IN_MS, D.RANGE_SCANS,
	D.INDEX_LOOKUPS FROM (SELECT DATABASE_ID, 
	OBJECT_ID, ROW_NUMBER() OVER (PARTITION BY
	DATABASE_ID ORDER BY
	SUM(PAGE_IO_LATCH_WAIT_IN_MS) DESC) AS
	ROW_NUMBER, SUM(PAGE_IO_LATCH_WAIT_COUNT) AS
	PAGE_IO_LATCH_WAIT_COUNT, 
	SUM(PAGE_IO_LATCH_WAIT_IN_MS) AS
	PAGE_IO_LATCH_WAIT_IN_MS, 
	SUM(RANGE_SCAN_COUNT) AS RANGE_SCANS, 
	SUM(SINGLETON_LOOKUP_COUNT) AS
	INDEX_LOOKUPS FROM
	SYS.DM_DB_INDEX_OPERATIONAL_STATS(NULL, NULL, 
	NULL, NULL) WHERE PAGE_IO_LATCH_WAIT_COUNT > 0
	GROUP BY DATABASE_ID, OBJECT_ID ) AS D LEFT JOIN
	(SELECT DISTINCT DATABASE_ID, OBJECT_ID FROM
	SYS.DM_DB_MISSING_INDEX_DETAILS) AS MID ON
	MID.DATABASE_ID = D.DATABASE_ID AND
	MID.OBJECT_ID = D.OBJECT_ID WHERE
	D.ROW_NUMBER>20 ORDER BY
	PAGE_IO_LATCH_WAIT_COUNT DESC