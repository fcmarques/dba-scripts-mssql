USE MASTER
GO

IF(SELECT OBJECT_ID('SP_SHOWINDEX')) IS NOT NULL
BEGIN
	DROP PROCEDURE SP_SHOWINDEX
END

GO

CREATE PROCEDURE SP_SHOWINDEX
/*-------------------------------------------------------------------------------------------------------
Nome Procedure: SP_SHOWINDEX
Projeto.......: SCRIPTS
Versão........: 1.0.0.1
---------------------------------------------------------------------------------------------------------

SQL Server edições suportadas: SQL Server 2005 e superiores.

---------------------------------------------------------------------------------------------------------
Autor                            Data                            Descrição
---------------------------------------------------------------------------------------------------------
Paulo Katsuo Katayama Jr        01/01/2014     Criação do script para consulta personalizada dos indices.
Reginaldo da Cruz Silva         27/11/2016     Padronização de campos e implementação da procedure.


Revisão:
Reginaldo da Cruz Silva

Duvidas e sugestões:
https://blogdojamal.wordpress.com/

---------------------------------------------------------------------------------------------------------*/
@TABLE_NAME		      VARCHAR(100) = '',
@INDEX_DETAILS		  BIT = 0,
@INDEX_FRAGMENTATION  BIT = 0,
@NOTUTILIZED		  BIT = 0,
@LIMITED			  BIT = 0,
@IS_DISABLED          BIT = 0,
@HELP				  BIT = 0
AS

IF(@HELP <> 0)
BEGIN
PRINT 
'
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
													  SP_SHOWINDEX
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
Nome Procedure: SP_SHOWINDEX
Projeto.......: SCRIPTS
Versão........: 1.0.0.1
---------------------------------------------------------------------------------------------------------

SQL Server edições suportadas: SQL Server 2005 e superiores.

---------------------------------------------------------------------------------------------------------
Autor                            Data                            Descrição
---------------------------------------------------------------------------------------------------------
Paulo Katsuo Katayama Jr        01/01/2014     Criação do script para consulta personalizada dos indices.
Reginaldo da Cruz Silva         27/11/2016     Padronização de campos e implementação da procedure.
---------------------------------------------------------------------------------------------------------

Revisão:
Reginaldo da Cruz Silva

Duvidas e sugestões:
https://blogdojamal.wordpress.com/


>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
													PARAMETROS
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>

 PARAMETRO									DESCRIÇÃO 
 
@TABLE_NAME				- FILTRA APENAS INDICES DA TABELA INFORMADA 
@INDEX_DETAILS			- MOSTRA MAIS DETALHES DO INDICE (INDEX PAGE COUNT)
@INDEX_FRAGMENTATION	- MOSTRA FRAGMENTAÇÃO DO INDICE (INDEX FRAGMENTATION) ESTE PROCESSO PODE SER LENTO
@NOTUTILIZED			- MOSTRA INDICES NUNCA UTILIZADOS OU A MAIS DE UM MES SEM SER FEITO UM SEEK.
@LIMITED				- LIMITA AS COLUNAS QUE SÃO APRESENTADAS PARA UMA VISUALIZAÇÃO MAIS SIMPLES
@IS_DISABLED			- MOSTRA INDICES DESABILITADOS
@HELP					- MOSTRA DESCRIÇÃO DAS COLUNAS, PARAMETROS E CABEÇALHO.


>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
												 DESCRIÇÃO DAS COLUNAS
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>

   COLUNA											DESCRIÇÃO    

SERVER_NAME						- NOME DO SERVIDOR QUE ESTA LOGADO
DATABASE_NAME					- NOME DA BASE DE DADOS EM USO
TABLE_NAME						- NOME DA TABELA QUE PERTENCE O INDICE
INDEX_NAME						- NOME DO INDICE
PK_OR_INDEX						- MOSTRA SE O INDICE FOI CRIADO POR UMA PRIMARY KEY, VALORES PARA ESSA COLUNA:INDEX OU PK
INDEX_TYPE						- TIPO DO INDICE, VALORES PARA ESSA COLUNA: CLUSTERED E NONCLUSTERED
SEEKS							- NUMERO DE PESQUISAS(INDEX SEEK) EXECUTAS NESSE INDICE
SCANS							- NUMERO DE VARREDURAS(INDEX SCAN) EXECUTADAS NESSE INDICE
LOOKUPS							- NUMERO DE LOOKUPS EXECUTADOS NESSE INDICE
UPDATES							- NUMERO DE ALTERAÇÕES(INSERT, DELETE E UPDATE) EXECUTADAS NESSE INDICES
COLUMNS							- COLUNAS QUE PERTENCEM AO INDICE(ESTÃO EM TODOS OS NIVEIS DO INDICE)
INCLUDE_COLUMNS					- COLUNAS QUE PERTENCEM AO INDICE(ESTÃO APENAS NO NIVEL FOLHA DO INDICE)
DROP_COMMAND					- COMANDO PARA EXCLUIR O INDICE
CREATE COMMAND					- COMANDO PARA CRIAR O INDICE
PRIMARY_KEY						- INFORMA SE O INDICE É VINCULADO A UMA PRIMARY KEY
INDEX_UNIQUE					- INFORMA SE O INDICE PERTENCE A UMA CONSTRAINT UNIQUE
UNIQUE_KEY						- INFORMA SE O INDICE É UM INDICE UNICO
LAST_SEEK						- MOSTRA ULTIMA VEZ QUE FOI REALIZADO UMA PESQUISA(INDEX SEEK) NO INDICE
LAST_SCAN						- MOSTRA ULTIMA VEZ QUE FOI EXECUTADO UMA VARREDURA(INDEX SCAN) NO INDICE
LAST_LOOKUP						- MOSTRA ULTIMA VEZ QUE FOI EXECUTADO UM LOOKUP NO INDICE
LAST_UODATE						- MOSTRA ULTIMA VEZ QUE O INDICE SOFRE UMA ALTERAÇÃO(INSERT, DELETE E UPDATE)
IS_DISABLED						- INFORMA SE O INDICE ESTA HABILITADO OU DESABILITADO
PAGE_COUNT						- QUANTIDADE DE PAGINAS DE 8K PARA ARMAZENAR DADOS, MOSTRASPAGINAS DO TIPO  IN_ROW_DATA,LOB E ROW_OVERFLOW
ROW_COUNT						- QUANTIDADE APROXIMADA DE LINHAS QUE POSSUI A TABELA
AVG_FRAGMENTATION_IN_PERCENT	- MEDIA DE FRAGMENTAÇÃO DO INDICE, REPRESENTAÇÃO EM %
PAGE_COUNT_FRAGMENTATION		- QUANTIDADE DE PAGINAS DE 8K, APENAS DO TIPO IN_ROW_DATA

>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>

'
RETURN
END
DECLARE @COMMAND VARCHAR(MAX) = ''

SET @COMMAND = 
'
SELECT	
' +
CASE WHEN @LIMITED <> 0 THEN 
'
		A.TABLE_NAME,
		A.INDEX_NAME,
		B.INDEX_TYPE,
		' + case when @INDEX_DETAILS <> 0 then 'PAGE_COUNT,ROW_COUNT,' else '' end + '
		' + case when @INDEX_FRAGMENTATION <> 0 then 'AVG_FRAGMENTATION_IN_PERCENT,PAGE_COUNT_FRAGMENTATION,' else '' end + '
		SEEKS,
		SCANS,
		LOOKUPS,
		UPDATES,
		COLUMNS,
		ISNULL(INCLUDE,'''') AS INCLUDE_COLUMNS,
		LAST_SEEK,
		LAST_UPDATE,
		IS_DISABLED
' ELSE 
'
		@@SERVERNAME AS SERVER_NAME,
		ISNULL(DATABASE_NAME,DB_NAME(DB_ID())) AS DATABASE_NAME,
		A.TABLE_NAME,
		A.INDEX_NAME,
		PK_OR_INDEX,
		B.INDEX_TYPE,
		ISNULL(SEEKS,0) AS SEEKS,
		ISNULL(SCANS,0) AS SCANS,
		ISNULL(LOOKUPS,0) AS LOOKUPS,
		ISNULL(UPDATES,0) AS UPDATES,
		' + case when @INDEX_DETAILS <> 0 then 'PAGE_COUNT,ROW_COUNT,' else '' end + '
		' + case when @INDEX_FRAGMENTATION <> 0 then 'AVG_FRAGMENTATION_IN_PERCENT,PAGE_COUNT_FRAGMENTATION,' else '' end + '
		COLUMNS,
		ISNULL(INCLUDE,'''') AS INCLUDE_COLUMNS,
		DROP_COMMAND,
		CREATE_COMMAND,
		PRIMARY_KEY,
		INDEX_UNIQUE,
		UNIQUE_KEY,
		LAST_SEEK,
		LAST_SCAN,
		LAST_LOOKUP,
		LAST_UPDATE,
		IS_DISABLED
' END + '
FROM (
		SELECT
		    DB_NAME(U.DATABASE_ID) AS DATABASE_NAME, 
			OBJECT_NAME(I.OBJECT_ID) AS TABLE_NAME, 
			I.NAME AS INDEX_NAME,
			MAX(CASE WHEN IS_PRIMARY_KEY = 0 THEN ''INDEX'' ELSE ''PK'' END) AS PK_OR_INDEX,
		    SUM(ISNULL(U.USER_SEEKS,0)) AS SEEKS, 
			SUM(ISNULL(U.USER_SCANS,0)) AS SCANS, 
			SUM(ISNULL(U.USER_LOOKUPS,0)) AS LOOKUPS,
			SUM(ISNULL(U.USER_UPDATES,0)) AS UPDATES,
		    MAX(U.LAST_USER_SEEK) AS LAST_SEEK, 
			MAX(U.LAST_USER_SCAN) AS LAST_SCAN,
		    MAX(U.LAST_USER_LOOKUP) AS LAST_LOOKUP, 
			MAX(U.LAST_USER_UPDATE) AS LAST_UPDATE,
			CASE WHEN I.IS_DISABLED = 1 THEN ''YES'' ELSE ''NO'' END IS_DISABLED
			' + case when @INDEX_DETAILS <> 0 then ',SUM(P.IN_ROW_USED_PAGE_COUNT+P.LOB_USED_PAGE_COUNT+P.ROW_OVERFLOW_USED_PAGE_COUNT) AS PAGE_COUNT,SUM(ROW_COUNT) ROW_COUNT' else '' end + '
			' + case when @INDEX_FRAGMENTATION <> 0 then ',AVG(S.AVG_FRAGMENTATION_IN_PERCENT) AS AVG_FRAGMENTATION_IN_PERCENT, AVG(S.PAGE_COUNT) AS PAGE_COUNT_FRAGMENTATION' else '' end + '			
		FROM
		    SYS.INDEXES AS I INNER JOIN SYS.SYSOBJECTS O ON I.OBJECT_ID = O.ID AND O.XTYPE = ''U''
		    LEFT OUTER JOIN SYS.DM_DB_INDEX_USAGE_STATS AS U ON I.OBJECT_ID = U.OBJECT_ID AND I.INDEX_ID = U.INDEX_ID AND U.DATABASE_ID = DB_ID()
		    ' + case when @INDEX_DETAILS <> 0 then 'LEFT JOIN  SYS.DM_DB_PARTITION_STATS P ON P.OBJECT_ID = I.OBJECT_ID AND P.INDEX_ID = I.INDEX_ID ' else '' end + '			    
		    ' + case when @INDEX_FRAGMENTATION <> 0 then 'LEFT JOIN  SYS.DM_DB_INDEX_PHYSICAL_STATS(DB_ID(), NULL, NULL, NULL, ''LIMITED'') S ON S.OBJECT_ID = I.OBJECT_ID AND S.INDEX_ID = I.INDEX_ID ' else '' end + '			    
		WHERE (U.DATABASE_ID = DB_ID() OR U.DATABASE_ID IS NULL) AND I.NAME IS NOT NULL 
		--' + case when @INDEX_FRAGMENTATION <> 0 then ' AND S.DATABASE_ID = DB_ID() ' else '' end + '
		' + case when @IS_DISABLED <> 0 then '  AND IS_DISABLED = 1 ' else '' end + '			    
		GROUP BY U.DATABASE_ID, I.OBJECT_ID, I.NAME,I.IS_DISABLED
	) A

LEFT JOIN (

			SELECT	TABLE_NAME, INDEX_NAME, PRIMARY_KEY, INDEX_UNIQUE, UNIQUE_KEY, INDEX_TYPE COLLATE SQL_Latin1_General_CP1_CI_AS INDEX_TYPE, 
					SUBSTRING(COLUMNS,1,LEN(COLUMNS)-1)COLUMNS, SUBSTRING([INCLUDE],1,LEN([INCLUDE])-1)[INCLUDE], 
					
					CASE WHEN PRIMARY_KEY = 1 THEN ''ALTER TABLE ''+TABLE_NAME+'' ADD CONSTRAINT ''+UPPER(INDEX_NAME)+'' PRIMARY KEY ''+INDEX_TYPE COLLATE SQL_Latin1_General_CP1_CI_AS +'' (''+SUBSTRING(COLUMNS,1,LEN(COLUMNS)-1)+'')''
						WHEN UNIQUE_KEY = 1 THEN ''ALTER TABLE ''+TABLE_NAME+'' ADD CONSTRAINT ''+UPPER(INDEX_NAME)+'' UNIQUE ''+INDEX_TYPE COLLATE SQL_Latin1_General_CP1_CI_AS +'' (''+SUBSTRING(COLUMNS,1,LEN(COLUMNS)-1)+'')''
						WHEN PRIMARY_KEY = 0 AND UNIQUE_KEY = 0 AND INDEX_UNIQUE = 1 THEN ''CREATE UNIQUE ''+INDEX_TYPE COLLATE SQL_Latin1_General_CP1_CI_AS +'' INDEX ''+UPPER(INDEX_NAME)+ '' ON ''+TABLE_NAME+'' (''+SUBSTRING(COLUMNS,1,LEN(COLUMNS)-1)+'')''+ CASE WHEN [INCLUDE] IS NOT NULL THEN '' INCLUDE (''+SUBSTRING([INCLUDE],1,LEN([INCLUDE])-1)+'')'' ELSE '''' END
						WHEN PRIMARY_KEY = 0 AND UNIQUE_KEY = 0 AND INDEX_UNIQUE = 0 THEN ''CREATE ''+INDEX_TYPE COLLATE SQL_Latin1_General_CP1_CI_AS +'' INDEX ''+UPPER(INDEX_NAME)+ '' ON ''+TABLE_NAME+'' (''+SUBSTRING(COLUMNS,1,LEN(COLUMNS)-1)+'')''+ CASE WHEN [INCLUDE] IS NOT NULL THEN '' INCLUDE (''+SUBSTRING([INCLUDE],1,LEN([INCLUDE])-1)+'')'' ELSE '''' END END AS CREATE_COMMAND,
			
					CASE WHEN PRIMARY_KEY = 1 THEN ''ALTER TABLE ''+TABLE_NAME+'' DROP CONSTRAINT ''+INDEX_NAME
						WHEN UNIQUE_KEY = 1 THEN ''ALTER TABLE ''+TABLE_NAME+'' DROP CONSTRAINT ''+INDEX_NAME
						WHEN PRIMARY_KEY = 0 AND UNIQUE_KEY = 0 AND INDEX_UNIQUE = 1 THEN ''DROP INDEX ''+INDEX_NAME+ '' ON ''+TABLE_NAME 
						WHEN PRIMARY_KEY = 0 AND UNIQUE_KEY = 0 AND INDEX_UNIQUE = 0 THEN ''DROP INDEX ''+INDEX_NAME+ '' ON ''+TABLE_NAME END AS DROP_COMMAND
			
			FROM(
			SELECT	TABLE_NAME, 
					INDEX_NAME,
					MAX(CAST(IS_PRIMARY_KEY AS INT))PRIMARY_KEY,
					MAX(CAST(IS_UNIQUE AS INT))INDEX_UNIQUE,
					MAX(CAST(IS_UNIQUE_CONSTRAINT AS INT))UNIQUE_KEY,
					MAX(TYPE_DESC) AS INDEX_TYPE,
					
				(	SELECT CAMPO + '','' AS [text()]
					FROM (	SELECT	S.NAME AS TABLE_NAME, S6.NAME AS INDEX_NAME, S2.NAME AS CAMPO, S6.INDEX_COLUMN_ID AS ORDEM, S6.IS_INCLUDED_COLUMN AS INCLUD	
							FROM	[DBO].[SYSOBJECTS] S 
							INNER JOIN [DBO].[SYSCOLUMNS]		S2 ON S.ID = S2.ID
							INNER JOIN [DBO].[SYSTYPES]			S3 ON S2.XTYPE = S3.XTYPE AND S2.XUSERTYPE = S3.XUSERTYPE 
							INNER JOIN [SYS].[SCHEMAS]			S4 ON S.[UID] = S4.[SCHEMA_ID]
							LEFT  JOIN [SYS].[IDENTITY_COLUMNS]	S5 ON S2.ID = S5.[OBJECT_ID] AND S2.COLID = S5.COLUMN_ID
							LEFT  JOIN (SELECT S.[OBJECT_ID], S.NAME, S.TYPE_DESC, ISNULL(COLUMN_ID,0) AS COLUMN_ID, INDEX_COLUMN_ID, IS_INCLUDED_COLUMN
										FROM	[SYS].[INDEXES] S 
										INNER JOIN [SYS].[INDEX_COLUMNS] S2 ON S.[OBJECT_ID] = S2.[OBJECT_ID] AND S.INDEX_ID = S2.INDEX_ID
										)S6 ON S6.[OBJECT_ID] = S.ID AND S6.COLUMN_ID = S2.COLID
							WHERE S.XTYPE = ''U'' AND S4.NAME = ''DBO'' AND S6.COLUMN_ID <> 0 AND IS_INCLUDED_COLUMN = 0 
						)A 
					WHERE A.TABLE_NAME = B.TABLE_NAME AND A.INDEX_NAME = B.INDEX_NAME 
					ORDER BY TABLE_NAME,INDEX_NAME,ORDEM FOR XML PATH(''''))COLUMNS,
				
			
				(	SELECT CAMPO + '','' AS [text()]
					FROM (	SELECT	S.NAME AS TABLE_NAME, S6.NAME AS INDEX_NAME, S2.NAME AS CAMPO, S6.INDEX_COLUMN_ID AS ORDEM, S6.IS_INCLUDED_COLUMN AS INCLUD	
							FROM	[DBO].[SYSOBJECTS] S 
							INNER JOIN [DBO].[SYSCOLUMNS]		S2 ON S.ID = S2.ID
							INNER JOIN [DBO].[SYSTYPES]			S3 ON S2.XTYPE = S3.XTYPE AND S2.XUSERTYPE = S3.XUSERTYPE 
							INNER JOIN [SYS].[SCHEMAS]			S4 ON S.[UID] = S4.[SCHEMA_ID]
							LEFT  JOIN [SYS].[IDENTITY_COLUMNS]	S5 ON S2.ID = S5.[OBJECT_ID] AND S2.COLID = S5.COLUMN_ID
							LEFT  JOIN (SELECT S.[OBJECT_ID], S.NAME, S.TYPE_DESC, ISNULL(COLUMN_ID,0) AS COLUMN_ID, INDEX_COLUMN_ID, IS_INCLUDED_COLUMN
										FROM	[SYS].[INDEXES] S 
										INNER JOIN [SYS].[INDEX_COLUMNS] S2 ON S.[OBJECT_ID] = S2.[OBJECT_ID] AND S.INDEX_ID = S2.INDEX_ID
										)S6 ON S6.[OBJECT_ID] = S.ID AND S6.COLUMN_ID = S2.COLID
							WHERE S.XTYPE = ''U'' AND S4.NAME = ''DBO'' AND S6.COLUMN_ID <> 0 AND IS_INCLUDED_COLUMN <> 0 
						)A 
					WHERE A.TABLE_NAME = B.TABLE_NAME AND A.INDEX_NAME = B.INDEX_NAME 
					ORDER BY TABLE_NAME,INDEX_NAME,ORDEM FOR XML PATH(''''))[INCLUDE]
			
			FROM (
			SELECT S.NAME AS TABLE_NAME, S6.NAME AS INDEX_NAME, TYPE_DESC, IS_PRIMARY_KEY, IS_UNIQUE, IS_UNIQUE_CONSTRAINT, S2.NAME AS CAMPO, S6.INDEX_COLUMN_ID AS ORDEM, S6.IS_INCLUDED_COLUMN AS INCLUD
			FROM	[DBO].[SYSOBJECTS] S 
						INNER JOIN [DBO].[SYSCOLUMNS]		S2 ON S.ID = S2.ID
						INNER JOIN [DBO].[SYSTYPES]			S3 ON S2.XTYPE = S3.XTYPE AND S2.XUSERTYPE = S3.XUSERTYPE 
						INNER JOIN [SYS].[SCHEMAS]			S4 ON S.[UID] = S4.[SCHEMA_ID]
						LEFT  JOIN [SYS].[IDENTITY_COLUMNS]	S5 ON S2.ID = S5.[OBJECT_ID] AND S2.COLID = S5.COLUMN_ID
						LEFT  JOIN (SELECT S.[OBJECT_ID], S.NAME, S.TYPE_DESC, IS_PRIMARY_KEY, IS_UNIQUE, IS_UNIQUE_CONSTRAINT, ISNULL(COLUMN_ID,0) AS COLUMN_ID, INDEX_COLUMN_ID, IS_INCLUDED_COLUMN
									FROM	[SYS].[INDEXES] S 
											INNER JOIN [SYS].[INDEX_COLUMNS] S2 ON S.[OBJECT_ID] = S2.[OBJECT_ID] AND S.INDEX_ID = S2.INDEX_ID
									)S6 ON S6.[OBJECT_ID] = S.ID AND S6.COLUMN_ID = S2.COLID
				WHERE S.XTYPE = ''U'' AND S4.NAME = ''DBO'' AND S6.COLUMN_ID <> 0 
				
			)B
			GROUP BY TABLE_NAME, INDEX_NAME
			)CONSULTA 
		) B ON A.TABLE_NAME= B.TABLE_NAME AND A.INDEX_NAME = B.INDEX_NAME
'
+
CASE WHEN @TABLE_NAME <> '' THEN 
'WHERE A.TABLE_NAME = '''+@TABLE_NAME+'''
'
ELSE '' END +
CASE WHEN @TABLE_NAME = '' AND @NOTUTILIZED <> 0
THEN 
' WHERE (A.SEEKS <= 0 OR DATEDIFF(DAY,A.LAST_SEEK,GETDATE()) > 30)
'
WHEN @TABLE_NAME <> '' AND @NOTUTILIZED <> 0
THEN 
' AND (A.SEEKS <= 0 OR DATEDIFF(DAY,A.LAST_SEEK,GETDATE()) > 30)
'
ELSE '' 
END 
+ ' ORDER BY TABLE_NAME,SEEKS DESC, SCANS DESC, LOOKUPS DESC'

EXEC (@COMMAND)
